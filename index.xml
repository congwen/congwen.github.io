<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>丛文的博客</title>
    <link>https://congwen.github.io/</link>
    <description>Recent content on 丛文的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 24 Aug 2022 12:48:43 +0800</lastBuildDate><atom:link href="https://congwen.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[leetcode]删除排序链表中的重复元素 II</title>
      <link>https://congwen.github.io/post/leetcode/82-remove-duplicates-from-sorted-list-ii/</link>
      <pubDate>Wed, 24 Aug 2022 12:48:43 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/leetcode/82-remove-duplicates-from-sorted-list-ii/</guid>
      <description>题目 给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。 示例1: 输入：head = [1,2,3,3,4,4,5] 输出：[1,</description>
    </item>
    
    <item>
      <title>[leetcode]剑指 Offer 37. 序列化二叉树</title>
      <link>https://congwen.github.io/post/sordoffer/37-xu-lie-hua-er-cha-shu-lcof/</link>
      <pubDate>Tue, 09 Aug 2022 12:27:30 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/37-xu-lie-hua-er-cha-shu-lcof/</guid>
      <description>题目 请实现两个函数，分别用来序列化和反序列化二叉树。 你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻</description>
    </item>
    
    <item>
      <title>[leetcode]剑指 Offer 36. 二叉搜索树与双向链表</title>
      <link>https://congwen.github.io/post/sordoffer/36-er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/</link>
      <pubDate>Thu, 04 Aug 2022 19:30:13 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/36-er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/</guid>
      <description>题目 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 我们希望将这个二叉</description>
    </item>
    
    <item>
      <title>[leetcode]剑指 Offer 33. 二叉搜索树的后序遍历序列</title>
      <link>https://congwen.github.io/post/sordoffer/33-er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</link>
      <pubDate>Wed, 03 Aug 2022 15:24:12 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/33-er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</guid>
      <description>题目 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互</description>
    </item>
    
    <item>
      <title>数据仓库-第3范式</title>
      <link>https://congwen.github.io/post/data-warehouse/3nf-model/</link>
      <pubDate>Tue, 02 Aug 2022 17:41:09 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/data-warehouse/3nf-model/</guid>
      <description>第3范式 1NF-无重复的列 数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性</description>
    </item>
    
    <item>
      <title>[leetcode]剑指 Offer 32 - III. 从上到下打印二叉树 III</title>
      <link>https://congwen.github.io/post/sordoffer/sordoffer-32-cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/</link>
      <pubDate>Tue, 02 Aug 2022 12:51:53 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/sordoffer-32-cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/</guid>
      <description>题目 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其</description>
    </item>
    
    <item>
      <title>[leetcode]剑指 Offer 32 - II. 从上到下打印二叉树 II</title>
      <link>https://congwen.github.io/post/sordoffer/sordoffer-32-cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/</link>
      <pubDate>Tue, 02 Aug 2022 12:30:24 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/sordoffer-32-cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/</guid>
      <description>题目 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 例如: 给定二叉树: [3,9,20,null,null,15,7] 3 / \ 9 20 / \ 15 7 返回其层次遍历结果： [</description>
    </item>
    
    <item>
      <title>[leetcode]剑指 Offer 31. 栈的压入、弹出序列</title>
      <link>https://congwen.github.io/post/sordoffer/sordoffer-31-zhan-de-ya-ru-dan-chu-xu-lie-lcof/</link>
      <pubDate>Tue, 02 Aug 2022 11:28:58 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/sordoffer-31-zhan-de-ya-ru-dan-chu-xu-lie-lcof/</guid>
      <description>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。 假设压入栈的所有数字均不相等。 例如，序列 {1,2,3,4,5} 是某栈的压栈序</description>
    </item>
    
    <item>
      <title>[leetcode]剑指 Offer 30. 包含min函数的栈</title>
      <link>https://congwen.github.io/post/sordoffer/sordoffer-30-bao-han-minhan-shu-de-zhan-lcof/</link>
      <pubDate>Tue, 02 Aug 2022 10:13:33 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/sordoffer-30-bao-han-minhan-shu-de-zhan-lcof/</guid>
      <description>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 示例: MinStack minStack = new</description>
    </item>
    
    <item>
      <title>[leetcode]剑指 Offer 29. 顺时针打印矩阵</title>
      <link>https://congwen.github.io/post/sordoffer/sordoffer29-shun-shi-zhen-da-yin-ju-zhen-lcof/</link>
      <pubDate>Mon, 01 Aug 2022 20:01:12 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/sordoffer29-shun-shi-zhen-da-yin-ju-zhen-lcof/</guid>
      <description>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例</description>
    </item>
    
    <item>
      <title>[leetcode]剑指 Offer 28. 对称的二叉树</title>
      <link>https://congwen.github.io/post/sordoffer/sordoffer-28-dui-cheng-de-er-cha-shu-lcof/</link>
      <pubDate>Mon, 01 Aug 2022 18:19:25 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/sordoffer-28-dui-cheng-de-er-cha-shu-lcof/</guid>
      <description>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \ 2 2 / \ / \ 3 4</description>
    </item>
    
    <item>
      <title>[leetcode]二叉树的完全性检验</title>
      <link>https://congwen.github.io/post/leetcode-958-check-completeness-of-a-binary-tree/</link>
      <pubDate>Fri, 29 Jul 2022 14:58:11 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/leetcode-958-check-completeness-of-a-binary-tree/</guid>
      <description>给定一个二叉树的 root ，确定它是否是一个 完全二叉树 。 在一个 完全二叉树 中，除了最后一个关卡外，所有关卡都是完全被填满的，并且最后一个关卡中的所有节</description>
    </item>
    
    <item>
      <title>Hive排序窗口函数row_number&#43;rank&#43;dense_rank的区别</title>
      <link>https://congwen.github.io/post/data-warehouse/hive%E6%8E%92%E5%BA%8F%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0row_number&#43;rank&#43;dense_rank%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Thu, 21 Oct 2021 10:27:53 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/data-warehouse/hive%E6%8E%92%E5%BA%8F%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0row_number&#43;rank&#43;dense_rank%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>三者的区别 rank()排序相同时会重复，总数不变，即会出现1、1、3这样的排序结果； dense_rank()排序相同时会重复，总数会减少，即</description>
    </item>
    
    <item>
      <title>并发、并行、串行的区别</title>
      <link>https://congwen.github.io/post/java/%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E4%B8%B2%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 10 Oct 2021 14:30:34 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E4%B8%B2%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>串行 在时间上不可能发生重叠，前一个任务没搞定，下一个任务就只能等着 并行 在时间上是重叠的，两个任务在 同一时刻互不干扰 的同时执行 并发 允许两个任务</description>
    </item>
    
    <item>
      <title>ThreadLocal的原理和使用场景</title>
      <link>https://congwen.github.io/post/java/threadlocal%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Sun, 10 Oct 2021 14:18:48 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/threadlocal%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</guid>
      <description>ThreadLocal的原理 每一个Thread对象均含有一个ThreadLocalMap类型的成员变量threadLocals，它存储本线程</description>
    </item>
    
    <item>
      <title>Java多线程中sleep、wait、join、yield的区别</title>
      <link>https://congwen.github.io/post/java/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%ADsleepwaitjoinyield%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 20:23:43 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%ADsleepwaitjoinyield%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>锁池 所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个线程得到，则其他线程需要在这个锁池进行等待，当前面的线程释放同步</description>
    </item>
    
    <item>
      <title>Java线程的生命周期中的状态</title>
      <link>https://congwen.github.io/post/java/java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Sat, 09 Oct 2021 20:18:36 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>线程通常有五种状态 新建状态（New）：新创建了一个线程对象。 就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start方</description>
    </item>
    
    <item>
      <title>Java的GC如何判断对象可以被回收</title>
      <link>https://congwen.github.io/post/java/java%E7%9A%84gc%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6/</link>
      <pubDate>Sat, 09 Oct 2021 20:15:18 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E7%9A%84gc%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6/</guid>
      <description>引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收 可达性分析法：从 GC Roots 开始向下搜索，搜索</description>
    </item>
    
    <item>
      <title>Java类加载器</title>
      <link>https://congwen.github.io/post/java/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</link>
      <pubDate>Sat, 09 Oct 2021 19:35:58 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</guid>
      <description>JDK自带有三个类加载器：bootstrap ClassLoader、ExtClassLoader、AppClassLoader。 BootSt</description>
    </item>
    
    <item>
      <title>ConcurrentHashMap原理，jdk7和jdk8版本的区别</title>
      <link>https://congwen.github.io/post/java/concurrenthashmap%E5%8E%9F%E7%90%86jdk7%E5%92%8Cjdk8%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 17:57:36 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/concurrenthashmap%E5%8E%9F%E7%90%86jdk7%E5%92%8Cjdk8%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>jdk7版本 数据结构：ReentrantLock+Segment+HashEntry，一个Segment中包含一个HashEntry数组，每</description>
    </item>
    
    <item>
      <title>Java的String、StringBuffer、StringBuilder区别</title>
      <link>https://congwen.github.io/post/java/java%E7%9A%84stringstringbufferstringbuilder%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 17:51:58 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E7%9A%84stringstringbufferstringbuilder%E5%8C%BA%E5%88%AB/</guid>
      <description>String是final修饰的，不可变，每次操作都会产生新的String对象 StringBuffer和StringBuilder都是在原对象</description>
    </item>
    
    <item>
      <title>Java的final关键字使用方法</title>
      <link>https://congwen.github.io/post/java/java%E7%9A%84final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 09 Oct 2021 17:48:17 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E7%9A%84final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description>修饰类：表示类不可被继承修饰方法：表示方法不可被子类覆盖，但是可以重载 修饰变量：表示变量一旦被赋值就不可以更改它的值。 修饰成员变量 如果fin</description>
    </item>
    
    <item>
      <title>==和equals比较</title>
      <link>https://congwen.github.io/post/java/%E5%92%8Cequals%E6%AF%94%E8%BE%83/</link>
      <pubDate>Sat, 09 Oct 2021 17:15:20 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E5%92%8Cequals%E6%AF%94%E8%BE%83/</guid>
      <description>一、对象类型不同 1、equals()：是超类Object中的方法。 2、==：是操作符。 二、比较的对象不同 1、equals()：用来检测两个对</description>
    </item>
    
    <item>
      <title>Java面向对象</title>
      <link>https://congwen.github.io/post/java/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sat, 09 Oct 2021 17:15:20 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>什么是面向对象 什么是面向对象？ 对比面向过程，是两种不同的处理问题的角度 面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者（</description>
    </item>
    
    <item>
      <title>System.gc()和Runtime.gc()会做什么事情</title>
      <link>https://congwen.github.io/post/java/system.gc%E5%92%8Cruntime.gc%E4%BC%9A%E5%81%9A%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85/</link>
      <pubDate>Sat, 09 Oct 2021 16:43:46 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/system.gc%E5%92%8Cruntime.gc%E4%BC%9A%E5%81%9A%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85/</guid>
      <description>GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳</description>
    </item>
    
    <item>
      <title>Java中垃圾回收有什么目的</title>
      <link>https://congwen.github.io/post/java/java%E4%B8%AD%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%89%E4%BB%80%E4%B9%88%E7%9B%AE%E7%9A%84/</link>
      <pubDate>Sat, 09 Oct 2021 16:38:04 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E4%B8%AD%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%89%E4%BB%80%E4%B9%88%E7%9B%AE%E7%9A%84/</guid>
      <description>垃圾回收(gc)的目的是释放堆中不需要保存的对象，达到内存的充分利用。 1.回收哪些对象的判定 垃圾回收最简单的思路是采用引用计数的方式，即记录</description>
    </item>
    
    <item>
      <title>Java中HashSet和TreeSet的区别</title>
      <link>https://congwen.github.io/post/java/java%E4%B8%ADhashset%E5%92%8Ctreeset%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 16:33:21 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E4%B8%ADhashset%E5%92%8Ctreeset%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>一、实现方式 HashSet：HashSet是哈希表实现的。 TreeSet：TreeSet是二差树实现的。 二、数据是否有序 HashSet：Ha</description>
    </item>
    
    <item>
      <title>优先级队列PriorityQueue</title>
      <link>https://congwen.github.io/post/java/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97priorityqueue/</link>
      <pubDate>Sat, 09 Oct 2021 16:22:18 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97priorityqueue/</guid>
      <description>优先级队列 PriorityQueue PriorityQueue 类在 Java 1.5 中引入 PriorityQueue 是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的 Comparator 在队列实例化的时排序。 PriorityQueue 不允许</description>
    </item>
    
    <item>
      <title>Comparable和Comparator接口的区别</title>
      <link>https://congwen.github.io/post/java/comparable%E5%92%8Ccomparator%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 15:47:34 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/comparable%E5%92%8Ccomparator%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来</description>
    </item>
    
    <item>
      <title>ArrayList和LinkedList类的用法及区别</title>
      <link>https://congwen.github.io/post/java/arraylist%E5%92%8Clinkedlist%E7%B1%BB%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 15:43:38 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/arraylist%E5%92%8Clinkedlist%E7%B1%BB%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%8C%BA%E5%88%AB/</guid>
      <description>List 是一个有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List 集合允许使用重复元素，可以通过索引来访问指定位置的集合元素。List</description>
    </item>
    
    <item>
      <title>数组Array和列表ArrayList有什么区别</title>
      <link>https://congwen.github.io/post/java/%E6%95%B0%E7%BB%84array%E5%92%8C%E5%88%97%E8%A1%A8arraylist%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 15:25:38 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E6%95%B0%E7%BB%84array%E5%92%8C%E5%88%97%E8%A1%A8arraylist%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</guid>
      <description>适用场景： 如果想要保存一些在整个程序运行期间都会存在而且不变的数据，我们可以将它们放进一个全局数组里， 但是如果我们单纯只是想要以数组的形式保</description>
    </item>
    
    <item>
      <title>HashMap和Hashtable有什么区别</title>
      <link>https://congwen.github.io/post/java/hashmap%E5%92%8Chashtable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 15:13:23 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/hashmap%E5%92%8Chashtable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</guid>
      <description>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synch</description>
    </item>
    
    <item>
      <title>HashCode和equals方法的重要性</title>
      <link>https://congwen.github.io/post/java/hashcode%E5%92%8Cequals%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</link>
      <pubDate>Sat, 09 Oct 2021 15:04:18 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/hashcode%E5%92%8Cequals%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</guid>
      <description>hashcode和equals组合在一起确定元素的唯一性。 查找元素时，如果单单使用equals来确定一个元素，需要对集合内的元素逐个调用eq</description>
    </item>
    
    <item>
      <title>Java中的HashMap的工作原理</title>
      <link>https://congwen.github.io/post/java/java%E4%B8%AD%E7%9A%84hashmap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sat, 09 Oct 2021 14:15:08 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E4%B8%AD%E7%9A%84hashmap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</guid>
      <description>HashMap的使用及特性 HashMap可以接受null键值和值，HashMap是非synchronized，HashMap储存的是键值对。</description>
    </item>
    
    <item>
      <title>快速失败fail Fast和安全失败fail Safe的区别</title>
      <link>https://congwen.github.io/post/java/%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5fail-fast%E5%92%8C%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5fail-safe%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 14:08:01 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5fail-fast%E5%92%8C%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5fail-safe%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>快速失败（fail-fast） 在使用迭代器对集合对象进行遍历的时候，如果 A 线程正在对集合进行遍历，此时 B 线程对集合进行修改（增加、删除、修改</description>
    </item>
    
    <item>
      <title>Iterator和ListIterator的区别是什么</title>
      <link>https://congwen.github.io/post/java/iterator%E5%92%8Clistiterator%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Sat, 09 Oct 2021 13:44:41 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/iterator%E5%92%8Clistiterator%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>Iterator和ListIterator的区别 Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历Li</description>
    </item>
    
    <item>
      <title>什么是迭代器</title>
      <link>https://congwen.github.io/post/java/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Sat, 09 Oct 2021 13:37:42 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>什么是迭代器 迭代器是一种设计模式，是一个对象，是一种通用的遍历集合元素的接口。 用来遍历Collection 集合的元素，且不需要了解集合的底层</description>
    </item>
    
    <item>
      <title>什么是死锁</title>
      <link>https://congwen.github.io/post/java/%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81/</link>
      <pubDate>Sat, 09 Oct 2021 13:05:00 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81/</guid>
      <description>什么是死锁 两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。 如何确保N个线</description>
    </item>
    
    <item>
      <title>Java在监视器内部是如何做线程同步的和程序应该做哪种级别的同步</title>
      <link>https://congwen.github.io/post/java/%E5%9C%A8%E7%9B%91%E8%A7%86%E5%99%A8%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%92%8C%E7%A8%8B%E5%BA%8F%E5%BA%94%E8%AF%A5%E5%81%9A%E5%93%AA%E7%A7%8D%E7%BA%A7%E5%88%AB%E7%9A%84%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Sat, 09 Oct 2021 13:01:45 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E5%9C%A8%E7%9B%91%E8%A7%86%E5%99%A8%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%92%8C%E7%A8%8B%E5%BA%8F%E5%BA%94%E8%AF%A5%E5%81%9A%E5%93%AA%E7%A7%8D%E7%BA%A7%E5%88%AB%E7%9A%84%E5%90%8C%E6%AD%A5/</guid>
      <description>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。本质都是对一个对象的监视器（monitor）进行获</description>
    </item>
    
    <item>
      <title>Java的synchronized的同步代码块和同步方法的区别</title>
      <link>https://congwen.github.io/post/java/java%E7%9A%84synchronized%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 12:44:02 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E7%9A%84synchronized%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>synchronized同步方法和同步代码块的区别 同步方法默认使用this或者当前类做为锁。 同步代码块可以选择以什么来加锁，比同步方法更精确</description>
    </item>
    
    <item>
      <title>创建线程有几种不同的方式</title>
      <link>https://congwen.github.io/post/java/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Sat, 09 Oct 2021 09:44:05 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%B9%E5%BC%8F/</guid>
      <description>1、继承Thread类 通过继承 Thread 类，并重写它的 run 方法，我们就可以创建一个线程 首先定义一个类来继承 Thread 类，重写 run 方法。 然后创建这个子类对象，并调</description>
    </item>
    
    <item>
      <title>进程和线程的区别是什么</title>
      <link>https://congwen.github.io/post/java/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Sat, 09 Oct 2021 09:29:37 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>功能：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位 开销：每个进程都有独立的内存空间，存放代码和数据段等，程序之间的切换</description>
    </item>
    
    <item>
      <title>Java的值传递和引用传递</title>
      <link>https://congwen.github.io/post/java/java%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</link>
      <pubDate>Sat, 09 Oct 2021 07:20:51 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</guid>
      <description>形参与实参 形参：方法被调用时需要传递进来的参数，如：func(int a)中的a，它只有在func被调用期间a才有意义，也就是会被分配内存空间</description>
    </item>
    
    <item>
      <title>Java接口与抽象类的区别</title>
      <link>https://congwen.github.io/post/java/java%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 08 Oct 2021 20:18:56 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>相同点 都不能被实例化 接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。 不同点 接口只有定义，不能有方法的实现，java 1</description>
    </item>
    
    <item>
      <title>为什么Java不支持多继承</title>
      <link>https://congwen.github.io/post/java/%E4%B8%BA%E4%BB%80%E4%B9%88java%E4%B8%8D%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Fri, 08 Oct 2021 19:57:28 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E4%B8%BA%E4%BB%80%E4%B9%88java%E4%B8%8D%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF/</guid>
      <description>关于这个问题，Java的创始人James Gosling曾经回答过，他表示： “Java之所以不支持一个类继承多个类，主要是因为在设计之初我们听</description>
    </item>
    
    <item>
      <title>Java中的方法覆盖Override和方法重载Overloade的区别</title>
      <link>https://congwen.github.io/post/java/java%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96override%E5%92%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BDoverloade%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 08 Oct 2021 18:56:34 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96override%E5%92%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BDoverloade%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>重写(Override) 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！ 重写的好处在于</description>
    </item>
    
    <item>
      <title>Java中Exception和Error的区别</title>
      <link>https://congwen.github.io/post/java/java%E4%B8%ADexception%E5%92%8Cerror%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 08 Oct 2021 17:22:25 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E4%B8%ADexception%E5%92%8Cerror%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>要做好异常处理就必须了解 Exception 和 Error 的区别，它们主要有以下异同 首先 Exception 和 Error 都是继承于 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（</description>
    </item>
    
    <item>
      <title>单例模式-双重校验锁</title>
      <link>https://congwen.github.io/post/singleton-pattern/</link>
      <pubDate>Tue, 24 Aug 2021 16:51:41 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/singleton-pattern/</guid>
      <description>采用双锁机制，安全且在多线程情况下能保持高性能。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Singleton{ private static volatile Singleton instance; private Singleton(){} public static Singleton getInstance(){ if(instance == null){ // 判断对象是否以及实例化过</description>
    </item>
    
    <item>
      <title>Clickhouse位图（bitmap）的使用</title>
      <link>https://congwen.github.io/post/bitmap-in-clickhouse/</link>
      <pubDate>Tue, 03 Aug 2021 16:44:13 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/bitmap-in-clickhouse/</guid>
      <description>可以先看下官方文档，也可以参考下这篇文章，写得很详细 1. 构建bitmap 位图对象有两种构造方法。一个是由聚合函数groupBitmapStat</description>
    </item>
    
    <item>
      <title>解决virtualbox网络配置hostonly后不生效的问题</title>
      <link>https://congwen.github.io/post/solve-virtualbox-network-config-of-hostonly/</link>
      <pubDate>Mon, 02 Aug 2021 16:35:01 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/solve-virtualbox-network-config-of-hostonly/</guid>
      <description>搭建了一个ubuntu的虚拟机，网卡配置了nat和hostonly,nat可以实现虚拟机连接外网，ping www.baidu.com 没有问题，问题是配置hoston</description>
    </item>
    
    <item>
      <title>VirtualBox的菜单栏被隐藏的解决办法</title>
      <link>https://congwen.github.io/post/solution-of-virtualbox-menu-is-hided/</link>
      <pubDate>Mon, 02 Aug 2021 15:13:37 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/solution-of-virtualbox-menu-is-hided/</guid>
      <description>搞不懂virtualbox为什么有时会隐藏顶部菜单栏，在Google里百度了一下，使用右Ctrl+C可以重新打开菜单栏，注意一定要是右Ctr</description>
    </item>
    
    <item>
      <title>SSL Error Syscall in Connection to Github 443</title>
      <link>https://congwen.github.io/post/ssl-error-syscall-in-connection-to-github-443/</link>
      <pubDate>Mon, 02 Aug 2021 11:56:54 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/ssl-error-syscall-in-connection-to-github-443/</guid>
      <description>因为我的电脑装了翻墙软件，导致每次往github上push代码时会报 OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443，着实很头疼，于是在Google</description>
    </item>
    
    <item>
      <title>在Ubuntu中安装clickhouse</title>
      <link>https://congwen.github.io/post/clickhouse-install-in-ubuntu/</link>
      <pubDate>Mon, 02 Aug 2021 10:32:30 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/clickhouse-install-in-ubuntu/</guid>
      <description>上篇文章介绍了如何安装Ubuntu server，接下来我们看下如何在Ubuntu里安装clickhouse 官方文档 我们可以先看下官方文档,里</description>
    </item>
    
    <item>
      <title>在Virtualbox中安装Ubuntu server</title>
      <link>https://congwen.github.io/post/install-ubuntu-server-in-virtualbox/</link>
      <pubDate>Thu, 29 Jul 2021 16:51:46 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/install-ubuntu-server-in-virtualbox/</guid>
      <description>使用windows开发的同学，内心是非常渴望有一台Linux的开发机，马上安排！ 1. 下载Ubuntu server系统 下载网址：https://</description>
    </item>
    
    <item>
      <title>在win10系统中安装virtualbox</title>
      <link>https://congwen.github.io/post/install-virtualbox-in-windows10/</link>
      <pubDate>Thu, 29 Jul 2021 16:15:29 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/install-virtualbox-in-windows10/</guid>
      <description>1、下载virtualbox 进入virtualbox官网下载：https://www.virtualbox.org/wiki/Downloa</description>
    </item>
    
    <item>
      <title>归并排序（Merge Sort）</title>
      <link>https://congwen.github.io/post/merge-sort/</link>
      <pubDate>Mon, 11 Nov 2019 09:31:15 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/merge-sort/</guid>
      <description>算法原理 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一</description>
    </item>
    
    <item>
      <title>解决Git Pull,push每次都需要输入密码问题</title>
      <link>https://congwen.github.io/post/git-push-pull-no-passwd/</link>
      <pubDate>Tue, 05 Nov 2019 11:14:34 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/git-push-pull-no-passwd/</guid>
      <description>本地保存帐号密码 git bash 进入你的项目目录，输入： 1 git config --global credential.helper store 然后你会在你本地生成一个文本，上边记录你的账号和密码。当然这些你可以不用关心。 然后你</description>
    </item>
    
    <item>
      <title>希尔排序（Shell Sort）</title>
      <link>https://congwen.github.io/post/shell-sort/</link>
      <pubDate>Tue, 05 Nov 2019 09:29:19 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/shell-sort/</guid>
      <description>算法原理 希尔排序是把记录按表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个</description>
    </item>
    
    <item>
      <title>插入排序（Insertion Sort）</title>
      <link>https://congwen.github.io/post/insertion-sort/</link>
      <pubDate>Mon, 04 Nov 2019 09:30:34 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/insertion-sort/</guid>
      <description>算法原理 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序</description>
    </item>
    
    <item>
      <title>快速排序（Quick Sort）</title>
      <link>https://congwen.github.io/post/quick-sort/</link>
      <pubDate>Fri, 01 Nov 2019 19:21:14 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/quick-sort/</guid>
      <description>算法思路 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继</description>
    </item>
    
    <item>
      <title>冒泡排序（Bubble Sort）</title>
      <link>https://congwen.github.io/post/bubble-sort/</link>
      <pubDate>Fri, 25 Oct 2019 11:18:15 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/bubble-sort/</guid>
      <description>算法思路 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应</description>
    </item>
    
    <item>
      <title>剑指Offer-15：链表中倒数第k个结点</title>
      <link>https://congwen.github.io/post/sordoffer/sword-offer-14/</link>
      <pubDate>Mon, 21 Oct 2019 11:18:15 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/sword-offer-14/</guid>
      <description>题目 输入一个链表，输出该链表中倒数第k个结点。 注意： k &amp;gt;= 0; 如果k大于链表长度，则返回 NULL; 样例 输入：链表：1-&amp;gt;2-&amp;gt;3-&amp;gt;4</description>
    </item>
    
    <item>
      <title>剑指Offer-05：从尾到头打印链表</title>
      <link>https://congwen.github.io/post/sordoffer/soword-offer-03/</link>
      <pubDate>Fri, 18 Oct 2019 11:18:15 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/soword-offer-03/</guid>
      <description>题目 输入一个链表的头结点，按照 从尾到头 的顺序返回节点的值。 返回的结果用数组存储。 样例 输入：[2, 3, 5] 返回：[5, 3, 2] (一) 解题思路 通常，我们</description>
    </item>
    
  </channel>
</rss>
