<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on 丛文的博客</title>
    <link>https://congwen.github.io/tags/java/</link>
    <description>Recent content in java on 丛文的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 09 Oct 2021 15:25:38 +0800</lastBuildDate><atom:link href="https://congwen.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>数组Array和列表ArrayList有什么区别</title>
      <link>https://congwen.github.io/post/java/%E6%95%B0%E7%BB%84array%E5%92%8C%E5%88%97%E8%A1%A8arraylist%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 15:25:38 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E6%95%B0%E7%BB%84array%E5%92%8C%E5%88%97%E8%A1%A8arraylist%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</guid>
      <description>适用场景： 如果想要保存一些在整个程序运行期间都会存在而且不变的数据，我们可以将它们放进一个全局数组里， 但是如果我们单纯只是想要以数组的形式保</description>
    </item>
    
    <item>
      <title>HashMap和Hashtable有什么区别</title>
      <link>https://congwen.github.io/post/java/hashmap%E5%92%8Chashtable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 15:13:23 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/hashmap%E5%92%8Chashtable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</guid>
      <description>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synch</description>
    </item>
    
    <item>
      <title>HashCode和equals方法的重要性</title>
      <link>https://congwen.github.io/post/java/hashcode%E5%92%8Cequals%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</link>
      <pubDate>Sat, 09 Oct 2021 15:04:18 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/hashcode%E5%92%8Cequals%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</guid>
      <description>hashcode和equals组合在一起确定元素的唯一性。 查找元素时，如果单单使用equals来确定一个元素，需要对集合内的元素逐个调用eq</description>
    </item>
    
    <item>
      <title>Java中的HashMap的工作原理</title>
      <link>https://congwen.github.io/post/java/java%E4%B8%AD%E7%9A%84hashmap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sat, 09 Oct 2021 14:15:08 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E4%B8%AD%E7%9A%84hashmap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</guid>
      <description>HashMap的使用及特性 HashMap可以接受null键值和值，HashMap是非synchronized，HashMap储存的是键值对。</description>
    </item>
    
    <item>
      <title>快速失败fail Fast和安全失败fail Safe的区别</title>
      <link>https://congwen.github.io/post/java/%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5fail-fast%E5%92%8C%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5fail-safe%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 14:08:01 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5fail-fast%E5%92%8C%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5fail-safe%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>快速失败（fail-fast） 在使用迭代器对集合对象进行遍历的时候，如果 A 线程正在对集合进行遍历，此时 B 线程对集合进行修改（增加、删除、修改</description>
    </item>
    
    <item>
      <title>Iterator和ListIterator的区别是什么</title>
      <link>https://congwen.github.io/post/java/iterator%E5%92%8Clistiterator%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Sat, 09 Oct 2021 13:44:41 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/iterator%E5%92%8Clistiterator%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>Iterator和ListIterator的区别 Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历Li</description>
    </item>
    
    <item>
      <title>什么是迭代器</title>
      <link>https://congwen.github.io/post/java/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Sat, 09 Oct 2021 13:37:42 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>什么是迭代器 迭代器是一种设计模式，是一个对象，是一种通用的遍历集合元素的接口。 用来遍历Collection 集合的元素，且不需要了解集合的底层</description>
    </item>
    
    <item>
      <title>什么是死锁</title>
      <link>https://congwen.github.io/post/java/%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81/</link>
      <pubDate>Sat, 09 Oct 2021 13:05:00 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81/</guid>
      <description>什么是死锁 两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。 如何确保N个线</description>
    </item>
    
    <item>
      <title>Java在监视器内部是如何做线程同步的和程序应该做哪种级别的同步</title>
      <link>https://congwen.github.io/post/java/%E5%9C%A8%E7%9B%91%E8%A7%86%E5%99%A8%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%92%8C%E7%A8%8B%E5%BA%8F%E5%BA%94%E8%AF%A5%E5%81%9A%E5%93%AA%E7%A7%8D%E7%BA%A7%E5%88%AB%E7%9A%84%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Sat, 09 Oct 2021 13:01:45 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E5%9C%A8%E7%9B%91%E8%A7%86%E5%99%A8%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%92%8C%E7%A8%8B%E5%BA%8F%E5%BA%94%E8%AF%A5%E5%81%9A%E5%93%AA%E7%A7%8D%E7%BA%A7%E5%88%AB%E7%9A%84%E5%90%8C%E6%AD%A5/</guid>
      <description>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。本质都是对一个对象的监视器（monitor）进行获</description>
    </item>
    
    <item>
      <title>Java的synchronized的同步代码块和同步方法的区别</title>
      <link>https://congwen.github.io/post/java/java%E7%9A%84synchronized%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 12:44:02 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E7%9A%84synchronized%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>synchronized同步方法和同步代码块的区别 同步方法默认使用this或者当前类做为锁。 同步代码块可以选择以什么来加锁，比同步方法更精确</description>
    </item>
    
    <item>
      <title>创建线程有几种不同的方式</title>
      <link>https://congwen.github.io/post/java/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Sat, 09 Oct 2021 09:44:05 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%B9%E5%BC%8F/</guid>
      <description>1、继承Thread类 通过继承 Thread 类，并重写它的 run 方法，我们就可以创建一个线程 首先定义一个类来继承 Thread 类，重写 run 方法。 然后创建这个子类对象，并调</description>
    </item>
    
    <item>
      <title>进程和线程的区别是什么</title>
      <link>https://congwen.github.io/post/java/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Sat, 09 Oct 2021 09:29:37 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>功能：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位 开销：每个进程都有独立的内存空间，存放代码和数据段等，程序之间的切换</description>
    </item>
    
    <item>
      <title>Java的值传递和引用传递</title>
      <link>https://congwen.github.io/post/java/java%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</link>
      <pubDate>Sat, 09 Oct 2021 07:20:51 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</guid>
      <description>形参与实参 形参：方法被调用时需要传递进来的参数，如：func(int a)中的a，它只有在func被调用期间a才有意义，也就是会被分配内存空间</description>
    </item>
    
    <item>
      <title>Java接口与抽象类的区别</title>
      <link>https://congwen.github.io/post/java/java%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 08 Oct 2021 20:18:56 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>相同点 都不能被实例化 接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。 不同点 接口只有定义，不能有方法的实现，java 1</description>
    </item>
    
    <item>
      <title>为什么Java不支持多继承</title>
      <link>https://congwen.github.io/post/java/%E4%B8%BA%E4%BB%80%E4%B9%88java%E4%B8%8D%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Fri, 08 Oct 2021 19:57:28 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E4%B8%BA%E4%BB%80%E4%B9%88java%E4%B8%8D%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF/</guid>
      <description>关于这个问题，Java的创始人James Gosling曾经回答过，他表示： “Java之所以不支持一个类继承多个类，主要是因为在设计之初我们听</description>
    </item>
    
    <item>
      <title>Java中的方法覆盖Override和方法重载Overloade的区别</title>
      <link>https://congwen.github.io/post/java/java%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96override%E5%92%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BDoverloade%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 08 Oct 2021 18:56:34 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96override%E5%92%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BDoverloade%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>重写(Override) 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！ 重写的好处在于</description>
    </item>
    
    <item>
      <title>Java中Exception和Error的区别</title>
      <link>https://congwen.github.io/post/java/java%E4%B8%ADexception%E5%92%8Cerror%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 08 Oct 2021 17:22:25 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E4%B8%ADexception%E5%92%8Cerror%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>要做好异常处理就必须了解 Exception 和 Error 的区别，它们主要有以下异同 首先 Exception 和 Error 都是继承于 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（</description>
    </item>
    
  </channel>
</rss>
