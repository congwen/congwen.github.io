<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on 楼度笔墨的博客</title>
    <link>https://congwen.github.io/tags/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on 楼度笔墨的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 29 Jul 2022 14:58:11 +0800</lastBuildDate><atom:link href="https://congwen.github.io/tags/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[leetcode]二叉树的完全性检验</title>
      <link>https://congwen.github.io/post/leetcode-958-check-completeness-of-a-binary-tree/</link>
      <pubDate>Fri, 29 Jul 2022 14:58:11 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/leetcode-958-check-completeness-of-a-binary-tree/</guid>
      <description>给定一个二叉树的 root ，确定它是否是一个 完全二叉树 。 在一个 完全二叉树 中，除了最后一个关卡外，所有关卡都是完全被填满的，并且最后一个关卡中的所有节</description>
    </item>
    
    <item>
      <title>归并排序（Merge Sort）</title>
      <link>https://congwen.github.io/post/merge-sort/</link>
      <pubDate>Mon, 11 Nov 2019 09:31:15 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/merge-sort/</guid>
      <description>算法原理 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一</description>
    </item>
    
    <item>
      <title>希尔排序（Shell Sort）</title>
      <link>https://congwen.github.io/post/shell-sort/</link>
      <pubDate>Tue, 05 Nov 2019 09:29:19 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/shell-sort/</guid>
      <description>算法原理 希尔排序是把记录按表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个</description>
    </item>
    
    <item>
      <title>插入排序（Insertion Sort）</title>
      <link>https://congwen.github.io/post/insertion-sort/</link>
      <pubDate>Mon, 04 Nov 2019 09:30:34 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/insertion-sort/</guid>
      <description>算法原理 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序</description>
    </item>
    
    <item>
      <title>快速排序（Quick Sort）</title>
      <link>https://congwen.github.io/post/quick-sort/</link>
      <pubDate>Fri, 01 Nov 2019 19:21:14 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/quick-sort/</guid>
      <description>算法思路 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继</description>
    </item>
    
    <item>
      <title>冒泡排序（Bubble Sort）</title>
      <link>https://congwen.github.io/post/bubble-sort/</link>
      <pubDate>Fri, 25 Oct 2019 11:18:15 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/bubble-sort/</guid>
      <description>算法思路 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应</description>
    </item>
    
    <item>
      <title>剑指Offer-15：链表中倒数第k个结点</title>
      <link>https://congwen.github.io/post/sordoffer/sword-offer-14/</link>
      <pubDate>Mon, 21 Oct 2019 11:18:15 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/sword-offer-14/</guid>
      <description>题目 输入一个链表，输出该链表中倒数第k个结点。 注意： k &amp;gt;= 0; 如果k大于链表长度，则返回 NULL; 样例 输入：链表：1-&amp;gt;2-&amp;gt;3-&amp;gt;4</description>
    </item>
    
    <item>
      <title>剑指Offer-05：从尾到头打印链表</title>
      <link>https://congwen.github.io/post/sordoffer/soword-offer-03/</link>
      <pubDate>Fri, 18 Oct 2019 11:18:15 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/soword-offer-03/</guid>
      <description>题目 输入一个链表的头结点，按照 从尾到头 的顺序返回节点的值。 返回的结果用数组存储。 样例 输入：[2, 3, 5] 返回：[5, 3, 2] (一) 解题思路 通常，我们</description>
    </item>
    
  </channel>
</rss>
