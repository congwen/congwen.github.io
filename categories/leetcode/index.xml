<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on 丛文的博客</title>
    <link>https://congwen.github.io/categories/leetcode/</link>
    <description>Recent content in leetcode on 丛文的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 21 Oct 2024 12:41:18 +0800</lastBuildDate><atom:link href="https://congwen.github.io/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[leetcode]707. 设计链表</title>
      <link>https://congwen.github.io/post/leetcode/707-design-linked-list/</link>
      <pubDate>Mon, 21 Oct 2024 12:41:18 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/leetcode/707-design-linked-list/</guid>
      <description>题目 你需要实现一个链表类 MyLinkedList，支持以下操作： get(index): 获取链表中第 index 个节点的值。如果索引无效，则返回 -1。 addAtHead(value): 在链表头部添加一个值</description>
    </item>
    
    <item>
      <title>[leetcode]795. 区间子数组个数</title>
      <link>https://congwen.github.io/post/leetcode/795-number-of-subarrays-with-bounded-maximum/</link>
      <pubDate>Wed, 16 Oct 2024 14:04:27 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/leetcode/795-number-of-subarrays-with-bounded-maximum/</guid>
      <description>题目描述： 给定一个整数数组 A 和两个整数 L 和 R，你需要找到数组中有多少个子数组的元素都在 [L, R] 的范围内。 注意：子数组是连续的。 示例 输入：A = [1, 2,</description>
    </item>
    
    <item>
      <title>[leetcode]66. 加一</title>
      <link>https://congwen.github.io/post/leetcode/66-plus-one/</link>
      <pubDate>Wed, 16 Oct 2024 12:41:18 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/leetcode/66-plus-one/</guid>
      <description>题目 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除</description>
    </item>
    
    <item>
      <title>[leetcode]189. 轮转数组</title>
      <link>https://congwen.github.io/post/leetcode/189-rotate-array/</link>
      <pubDate>Wed, 16 Oct 2024 12:30:18 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/leetcode/189-rotate-array/</guid>
      <description>题目 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。 示例 1: 输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右轮转 1 步: [7,1,2,3,4,5,6] 向右轮转</description>
    </item>
    
    <item>
      <title>[leetcode]删除排序链表中的重复元素 II</title>
      <link>https://congwen.github.io/post/leetcode/82-remove-duplicates-from-sorted-list-ii/</link>
      <pubDate>Wed, 24 Aug 2022 12:48:43 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/leetcode/82-remove-duplicates-from-sorted-list-ii/</guid>
      <description>题目 给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。 示例1: 输入：head = [1,2,3,3,4,4,5] 输出：[1,</description>
    </item>
    
    <item>
      <title>[leetcode]剑指 Offer 37. 序列化二叉树</title>
      <link>https://congwen.github.io/post/sordoffer/37-xu-lie-hua-er-cha-shu-lcof/</link>
      <pubDate>Tue, 09 Aug 2022 12:27:30 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/37-xu-lie-hua-er-cha-shu-lcof/</guid>
      <description>题目 请实现两个函数，分别用来序列化和反序列化二叉树。 你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻</description>
    </item>
    
    <item>
      <title>[leetcode]剑指 Offer 36. 二叉搜索树与双向链表</title>
      <link>https://congwen.github.io/post/sordoffer/36-er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/</link>
      <pubDate>Thu, 04 Aug 2022 19:30:13 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/36-er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/</guid>
      <description>题目 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 我们希望将这个二叉</description>
    </item>
    
    <item>
      <title>[leetcode]剑指 Offer 33. 二叉搜索树的后序遍历序列</title>
      <link>https://congwen.github.io/post/sordoffer/33-er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</link>
      <pubDate>Wed, 03 Aug 2022 15:24:12 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/33-er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</guid>
      <description>题目 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互</description>
    </item>
    
    <item>
      <title>[leetcode]剑指 Offer 32 - III. 从上到下打印二叉树 III</title>
      <link>https://congwen.github.io/post/sordoffer/sordoffer-32-cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/</link>
      <pubDate>Tue, 02 Aug 2022 12:51:53 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/sordoffer-32-cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/</guid>
      <description>题目 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其</description>
    </item>
    
    <item>
      <title>[leetcode]剑指 Offer 32 - II. 从上到下打印二叉树 II</title>
      <link>https://congwen.github.io/post/sordoffer/sordoffer-32-cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/</link>
      <pubDate>Tue, 02 Aug 2022 12:30:24 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/sordoffer-32-cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/</guid>
      <description>题目 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 例如: 给定二叉树: [3,9,20,null,null,15,7] 3 / \ 9 20 / \ 15 7 返回其层次遍历结果： [</description>
    </item>
    
    <item>
      <title>[leetcode]剑指 Offer 31. 栈的压入、弹出序列</title>
      <link>https://congwen.github.io/post/sordoffer/sordoffer-31-zhan-de-ya-ru-dan-chu-xu-lie-lcof/</link>
      <pubDate>Tue, 02 Aug 2022 11:28:58 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/sordoffer-31-zhan-de-ya-ru-dan-chu-xu-lie-lcof/</guid>
      <description>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。 假设压入栈的所有数字均不相等。 例如，序列 {1,2,3,4,5} 是某栈的压栈序</description>
    </item>
    
    <item>
      <title>[leetcode]剑指 Offer 30. 包含min函数的栈</title>
      <link>https://congwen.github.io/post/sordoffer/sordoffer-30-bao-han-minhan-shu-de-zhan-lcof/</link>
      <pubDate>Tue, 02 Aug 2022 10:13:33 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/sordoffer-30-bao-han-minhan-shu-de-zhan-lcof/</guid>
      <description>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 示例: MinStack minStack = new</description>
    </item>
    
    <item>
      <title>[leetcode]剑指 Offer 29. 顺时针打印矩阵</title>
      <link>https://congwen.github.io/post/sordoffer/sordoffer29-shun-shi-zhen-da-yin-ju-zhen-lcof/</link>
      <pubDate>Mon, 01 Aug 2022 20:01:12 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/sordoffer29-shun-shi-zhen-da-yin-ju-zhen-lcof/</guid>
      <description>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例</description>
    </item>
    
    <item>
      <title>[leetcode]剑指 Offer 28. 对称的二叉树</title>
      <link>https://congwen.github.io/post/sordoffer/sordoffer-28-dui-cheng-de-er-cha-shu-lcof/</link>
      <pubDate>Mon, 01 Aug 2022 18:19:25 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/sordoffer-28-dui-cheng-de-er-cha-shu-lcof/</guid>
      <description>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \ 2 2 / \ / \ 3 4</description>
    </item>
    
    <item>
      <title>[leetcode]二叉树的完全性检验</title>
      <link>https://congwen.github.io/post/leetcode-958-check-completeness-of-a-binary-tree/</link>
      <pubDate>Fri, 29 Jul 2022 14:58:11 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/leetcode-958-check-completeness-of-a-binary-tree/</guid>
      <description>给定一个二叉树的 root ，确定它是否是一个 完全二叉树 。 在一个 完全二叉树 中，除了最后一个关卡外，所有关卡都是完全被填满的，并且最后一个关卡中的所有节</description>
    </item>
    
    <item>
      <title>剑指Offer-15：链表中倒数第k个结点</title>
      <link>https://congwen.github.io/post/sordoffer/sword-offer-14/</link>
      <pubDate>Mon, 21 Oct 2019 11:18:15 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/sword-offer-14/</guid>
      <description>题目 输入一个链表，输出该链表中倒数第k个结点。 注意： k &amp;gt;= 0; 如果k大于链表长度，则返回 NULL; 样例 输入：链表：1-&amp;gt;2-&amp;gt;3-&amp;gt;4</description>
    </item>
    
    <item>
      <title>剑指Offer-05：从尾到头打印链表</title>
      <link>https://congwen.github.io/post/sordoffer/soword-offer-03/</link>
      <pubDate>Fri, 18 Oct 2019 11:18:15 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/sordoffer/soword-offer-03/</guid>
      <description>题目 输入一个链表的头结点，按照 从尾到头 的顺序返回节点的值。 返回的结果用数组存储。 样例 输入：[2, 3, 5] 返回：[5, 3, 2] (一) 解题思路 通常，我们</description>
    </item>
    
  </channel>
</rss>
