<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on 楼度笔墨的博客</title>
    <link>https://congwen.github.io/categories/java/</link>
    <description>Recent content in java on 楼度笔墨的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 10 Oct 2021 14:30:34 +0800</lastBuildDate><atom:link href="https://congwen.github.io/categories/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>并发、并行、串行的区别</title>
      <link>https://congwen.github.io/post/java/%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E4%B8%B2%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 10 Oct 2021 14:30:34 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E4%B8%B2%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>串行 在时间上不可能发生重叠，前一个任务没搞定，下一个任务就只能等着 并行 在时间上是重叠的，两个任务在 同一时刻互不干扰 的同时执行 并发 允许两个任务</description>
    </item>
    
    <item>
      <title>ThreadLocal的原理和使用场景</title>
      <link>https://congwen.github.io/post/java/threadlocal%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Sun, 10 Oct 2021 14:18:48 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/threadlocal%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</guid>
      <description>ThreadLocal的原理 每一个Thread对象均含有一个ThreadLocalMap类型的成员变量threadLocals，它存储本线程</description>
    </item>
    
    <item>
      <title>Java多线程中sleep、wait、join、yield的区别</title>
      <link>https://congwen.github.io/post/java/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%ADsleepwaitjoinyield%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 20:23:43 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%ADsleepwaitjoinyield%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>锁池 所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个线程得到，则其他线程需要在这个锁池进行等待，当前面的线程释放同步</description>
    </item>
    
    <item>
      <title>Java线程的生命周期中的状态</title>
      <link>https://congwen.github.io/post/java/java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Sat, 09 Oct 2021 20:18:36 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>线程通常有五种状态 新建状态（New）：新创建了一个线程对象。 就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start方</description>
    </item>
    
    <item>
      <title>Java的GC如何判断对象可以被回收</title>
      <link>https://congwen.github.io/post/java/java%E7%9A%84gc%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6/</link>
      <pubDate>Sat, 09 Oct 2021 20:15:18 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E7%9A%84gc%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6/</guid>
      <description>引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收 可达性分析法：从 GC Roots 开始向下搜索，搜索</description>
    </item>
    
    <item>
      <title>Java类加载器</title>
      <link>https://congwen.github.io/post/java/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</link>
      <pubDate>Sat, 09 Oct 2021 19:35:58 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</guid>
      <description>JDK自带有三个类加载器：bootstrap ClassLoader、ExtClassLoader、AppClassLoader。 BootSt</description>
    </item>
    
    <item>
      <title>ConcurrentHashMap原理，jdk7和jdk8版本的区别</title>
      <link>https://congwen.github.io/post/java/concurrenthashmap%E5%8E%9F%E7%90%86jdk7%E5%92%8Cjdk8%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 17:57:36 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/concurrenthashmap%E5%8E%9F%E7%90%86jdk7%E5%92%8Cjdk8%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>jdk7版本 数据结构：ReentrantLock+Segment+HashEntry，一个Segment中包含一个HashEntry数组，每</description>
    </item>
    
    <item>
      <title>Java的String、StringBuffer、StringBuilder区别</title>
      <link>https://congwen.github.io/post/java/java%E7%9A%84stringstringbufferstringbuilder%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 17:51:58 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E7%9A%84stringstringbufferstringbuilder%E5%8C%BA%E5%88%AB/</guid>
      <description>String是final修饰的，不可变，每次操作都会产生新的String对象 StringBuffer和StringBuilder都是在原对象</description>
    </item>
    
    <item>
      <title>Java的final关键字使用方法</title>
      <link>https://congwen.github.io/post/java/java%E7%9A%84final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 09 Oct 2021 17:48:17 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E7%9A%84final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description>修饰类：表示类不可被继承修饰方法：表示方法不可被子类覆盖，但是可以重载 修饰变量：表示变量一旦被赋值就不可以更改它的值。 修饰成员变量 如果fin</description>
    </item>
    
    <item>
      <title>==和equals比较</title>
      <link>https://congwen.github.io/post/java/%E5%92%8Cequals%E6%AF%94%E8%BE%83/</link>
      <pubDate>Sat, 09 Oct 2021 17:15:20 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E5%92%8Cequals%E6%AF%94%E8%BE%83/</guid>
      <description>一、对象类型不同 1、equals()：是超类Object中的方法。 2、==：是操作符。 二、比较的对象不同 1、equals()：用来检测两个对</description>
    </item>
    
    <item>
      <title>Java面向对象</title>
      <link>https://congwen.github.io/post/java/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sat, 09 Oct 2021 17:15:20 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>什么是面向对象 什么是面向对象？ 对比面向过程，是两种不同的处理问题的角度 面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者（</description>
    </item>
    
    <item>
      <title>System.gc()和Runtime.gc()会做什么事情</title>
      <link>https://congwen.github.io/post/java/system.gc%E5%92%8Cruntime.gc%E4%BC%9A%E5%81%9A%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85/</link>
      <pubDate>Sat, 09 Oct 2021 16:43:46 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/system.gc%E5%92%8Cruntime.gc%E4%BC%9A%E5%81%9A%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85/</guid>
      <description>GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳</description>
    </item>
    
    <item>
      <title>Java中垃圾回收有什么目的</title>
      <link>https://congwen.github.io/post/java/java%E4%B8%AD%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%89%E4%BB%80%E4%B9%88%E7%9B%AE%E7%9A%84/</link>
      <pubDate>Sat, 09 Oct 2021 16:38:04 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E4%B8%AD%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%89%E4%BB%80%E4%B9%88%E7%9B%AE%E7%9A%84/</guid>
      <description>垃圾回收(gc)的目的是释放堆中不需要保存的对象，达到内存的充分利用。 1.回收哪些对象的判定 垃圾回收最简单的思路是采用引用计数的方式，即记录</description>
    </item>
    
    <item>
      <title>Java中HashSet和TreeSet的区别</title>
      <link>https://congwen.github.io/post/java/java%E4%B8%ADhashset%E5%92%8Ctreeset%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 16:33:21 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E4%B8%ADhashset%E5%92%8Ctreeset%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>一、实现方式 HashSet：HashSet是哈希表实现的。 TreeSet：TreeSet是二差树实现的。 二、数据是否有序 HashSet：Ha</description>
    </item>
    
    <item>
      <title>优先级队列PriorityQueue</title>
      <link>https://congwen.github.io/post/java/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97priorityqueue/</link>
      <pubDate>Sat, 09 Oct 2021 16:22:18 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97priorityqueue/</guid>
      <description>优先级队列 PriorityQueue PriorityQueue 类在 Java 1.5 中引入 PriorityQueue 是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的 Comparator 在队列实例化的时排序。 PriorityQueue 不允许</description>
    </item>
    
    <item>
      <title>Comparable和Comparator接口的区别</title>
      <link>https://congwen.github.io/post/java/comparable%E5%92%8Ccomparator%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 15:47:34 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/comparable%E5%92%8Ccomparator%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来</description>
    </item>
    
    <item>
      <title>ArrayList和LinkedList类的用法及区别</title>
      <link>https://congwen.github.io/post/java/arraylist%E5%92%8Clinkedlist%E7%B1%BB%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 15:43:38 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/arraylist%E5%92%8Clinkedlist%E7%B1%BB%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%8C%BA%E5%88%AB/</guid>
      <description>List 是一个有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List 集合允许使用重复元素，可以通过索引来访问指定位置的集合元素。List</description>
    </item>
    
    <item>
      <title>数组Array和列表ArrayList有什么区别</title>
      <link>https://congwen.github.io/post/java/%E6%95%B0%E7%BB%84array%E5%92%8C%E5%88%97%E8%A1%A8arraylist%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 15:25:38 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E6%95%B0%E7%BB%84array%E5%92%8C%E5%88%97%E8%A1%A8arraylist%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</guid>
      <description>适用场景： 如果想要保存一些在整个程序运行期间都会存在而且不变的数据，我们可以将它们放进一个全局数组里， 但是如果我们单纯只是想要以数组的形式保</description>
    </item>
    
    <item>
      <title>HashMap和Hashtable有什么区别</title>
      <link>https://congwen.github.io/post/java/hashmap%E5%92%8Chashtable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 15:13:23 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/hashmap%E5%92%8Chashtable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</guid>
      <description>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synch</description>
    </item>
    
    <item>
      <title>HashCode和equals方法的重要性</title>
      <link>https://congwen.github.io/post/java/hashcode%E5%92%8Cequals%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</link>
      <pubDate>Sat, 09 Oct 2021 15:04:18 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/hashcode%E5%92%8Cequals%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</guid>
      <description>hashcode和equals组合在一起确定元素的唯一性。 查找元素时，如果单单使用equals来确定一个元素，需要对集合内的元素逐个调用eq</description>
    </item>
    
    <item>
      <title>Java中的HashMap的工作原理</title>
      <link>https://congwen.github.io/post/java/java%E4%B8%AD%E7%9A%84hashmap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sat, 09 Oct 2021 14:15:08 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E4%B8%AD%E7%9A%84hashmap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</guid>
      <description>HashMap的使用及特性 HashMap可以接受null键值和值，HashMap是非synchronized，HashMap储存的是键值对。</description>
    </item>
    
    <item>
      <title>快速失败fail Fast和安全失败fail Safe的区别</title>
      <link>https://congwen.github.io/post/java/%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5fail-fast%E5%92%8C%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5fail-safe%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 14:08:01 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5fail-fast%E5%92%8C%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5fail-safe%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>快速失败（fail-fast） 在使用迭代器对集合对象进行遍历的时候，如果 A 线程正在对集合进行遍历，此时 B 线程对集合进行修改（增加、删除、修改</description>
    </item>
    
    <item>
      <title>Iterator和ListIterator的区别是什么</title>
      <link>https://congwen.github.io/post/java/iterator%E5%92%8Clistiterator%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Sat, 09 Oct 2021 13:44:41 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/iterator%E5%92%8Clistiterator%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>Iterator和ListIterator的区别 Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历Li</description>
    </item>
    
    <item>
      <title>什么是迭代器</title>
      <link>https://congwen.github.io/post/java/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Sat, 09 Oct 2021 13:37:42 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>什么是迭代器 迭代器是一种设计模式，是一个对象，是一种通用的遍历集合元素的接口。 用来遍历Collection 集合的元素，且不需要了解集合的底层</description>
    </item>
    
    <item>
      <title>什么是死锁</title>
      <link>https://congwen.github.io/post/java/%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81/</link>
      <pubDate>Sat, 09 Oct 2021 13:05:00 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81/</guid>
      <description>什么是死锁 两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。 如何确保N个线</description>
    </item>
    
    <item>
      <title>Java在监视器内部是如何做线程同步的和程序应该做哪种级别的同步</title>
      <link>https://congwen.github.io/post/java/%E5%9C%A8%E7%9B%91%E8%A7%86%E5%99%A8%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%92%8C%E7%A8%8B%E5%BA%8F%E5%BA%94%E8%AF%A5%E5%81%9A%E5%93%AA%E7%A7%8D%E7%BA%A7%E5%88%AB%E7%9A%84%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Sat, 09 Oct 2021 13:01:45 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E5%9C%A8%E7%9B%91%E8%A7%86%E5%99%A8%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%92%8C%E7%A8%8B%E5%BA%8F%E5%BA%94%E8%AF%A5%E5%81%9A%E5%93%AA%E7%A7%8D%E7%BA%A7%E5%88%AB%E7%9A%84%E5%90%8C%E6%AD%A5/</guid>
      <description>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。本质都是对一个对象的监视器（monitor）进行获</description>
    </item>
    
    <item>
      <title>Java的synchronized的同步代码块和同步方法的区别</title>
      <link>https://congwen.github.io/post/java/java%E7%9A%84synchronized%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 09 Oct 2021 12:44:02 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E7%9A%84synchronized%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>synchronized同步方法和同步代码块的区别 同步方法默认使用this或者当前类做为锁。 同步代码块可以选择以什么来加锁，比同步方法更精确</description>
    </item>
    
    <item>
      <title>创建线程有几种不同的方式</title>
      <link>https://congwen.github.io/post/java/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Sat, 09 Oct 2021 09:44:05 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%B9%E5%BC%8F/</guid>
      <description>1、继承Thread类 通过继承 Thread 类，并重写它的 run 方法，我们就可以创建一个线程 首先定义一个类来继承 Thread 类，重写 run 方法。 然后创建这个子类对象，并调</description>
    </item>
    
    <item>
      <title>进程和线程的区别是什么</title>
      <link>https://congwen.github.io/post/java/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Sat, 09 Oct 2021 09:29:37 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>功能：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位 开销：每个进程都有独立的内存空间，存放代码和数据段等，程序之间的切换</description>
    </item>
    
    <item>
      <title>Java的值传递和引用传递</title>
      <link>https://congwen.github.io/post/java/java%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</link>
      <pubDate>Sat, 09 Oct 2021 07:20:51 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</guid>
      <description>形参与实参 形参：方法被调用时需要传递进来的参数，如：func(int a)中的a，它只有在func被调用期间a才有意义，也就是会被分配内存空间</description>
    </item>
    
    <item>
      <title>Java接口与抽象类的区别</title>
      <link>https://congwen.github.io/post/java/java%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 08 Oct 2021 20:18:56 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>相同点 都不能被实例化 接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。 不同点 接口只有定义，不能有方法的实现，java 1</description>
    </item>
    
    <item>
      <title>为什么Java不支持多继承</title>
      <link>https://congwen.github.io/post/java/%E4%B8%BA%E4%BB%80%E4%B9%88java%E4%B8%8D%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Fri, 08 Oct 2021 19:57:28 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/%E4%B8%BA%E4%BB%80%E4%B9%88java%E4%B8%8D%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF/</guid>
      <description>关于这个问题，Java的创始人James Gosling曾经回答过，他表示： “Java之所以不支持一个类继承多个类，主要是因为在设计之初我们听</description>
    </item>
    
    <item>
      <title>Java中的方法覆盖Override和方法重载Overloade的区别</title>
      <link>https://congwen.github.io/post/java/java%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96override%E5%92%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BDoverloade%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 08 Oct 2021 18:56:34 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96override%E5%92%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BDoverloade%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>重写(Override) 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！ 重写的好处在于</description>
    </item>
    
    <item>
      <title>Java中Exception和Error的区别</title>
      <link>https://congwen.github.io/post/java/java%E4%B8%ADexception%E5%92%8Cerror%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 08 Oct 2021 17:22:25 +0800</pubDate>
      
      <guid>https://congwen.github.io/post/java/java%E4%B8%ADexception%E5%92%8Cerror%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>要做好异常处理就必须了解 Exception 和 Error 的区别，它们主要有以下异同 首先 Exception 和 Error 都是继承于 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（</description>
    </item>
    
  </channel>
</rss>
